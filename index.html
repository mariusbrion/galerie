<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expérience 3D Interactive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f5f5e6; /* Fond beige clair */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #333;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background: #555;
        }
        @media (max-width: 768px) {
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="fullscreenBtn">Plein écran</button>
        <button id="resetBtn">Réinitialiser la vue</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialisation de la scène
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5e6); // Fond beige clair

        // Caméra
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        // Rendu
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Améliore la netteté
        document.body.appendChild(renderer.domElement);

        // Contrôles OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Éclairage
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Images et descriptions
        const imageData = [
            { url: 'carte_chatellerault.webp', desc: 'Une belle vue de Châtellerault' },
            { url: 'carte_châtellerault.webp', desc: 'Carte historique de la région' },
            { url: 'tenerife.jpg', desc: 'San Cristóbal de La Laguna, ville historique du nord de Tenerife' },
            { url: 'amenagement.JPG', desc: 'Plan d’aménagement urbain détaillé' },
            { url: 'meriadek.jpg', desc: 'Vue du quartier Mériadeck à Bordeaux' },
            { url: 'Marseille.webp', desc: 'Paysage urbain vibrant de Marseille' },
            { url: 'chaban.webp', desc: 'Pont Chaban-Delmas, pont à levage vertical emblématique de Bordeaux' },
            { url: 'carte_chatellerault2.webp', desc: 'Une autre vue de Châtellerault' },
            { url: 'guggenheim.jpg', desc: 'Musée Guggenheim emblématique à Bilbao' }
        ];

        // Création des plans pour les images
        const planes = [];
        const loader = new THREE.TextureLoader();
        let selectedPlane = null;
        let loadedFont = null;

        // Font loader pour le texte
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/gentilis_regular.typeface.json', (font) => {
            loadedFont = font; // Stocker la police chargée
            imageData.forEach((data, index) => {
                loader.load(data.url, (texture) => {
                    // Optimisation des textures pour la qualité
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    const geometry = new THREE.PlaneGeometry(4, 3);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    
                    // Position en spirale
                    const angle = (index / imageData.length) * Math.PI * 2;
                    const radius = 8;
                    plane.position.set(
                        Math.cos(angle) * radius,
                        index * 2 - (imageData.length - 1),
                        Math.sin(angle) * radius
                    );
                    
                    // Inclinaison aléatoire
                    plane.rotation.x = (Math.random() - 0.5) * 0.3;
                    plane.rotation.y = (Math.random() - 0.5) * 0.3;
                    
                    scene.add(plane);

                    // Création du texte (initialement vide)
                    const textGeometry = new THREE.TextGeometry('', {
                        font: loadedFont,
                        size: 0.2, // Police réduite
                        height: 0.01
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: 0x333333,
                        transparent: true,
                        opacity: 0
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(
                        plane.position.x - 2,
                        plane.position.y - 2,
                        plane.position.z
                    );
                    textMesh.rotation.set(plane.rotation.x, plane.rotation.y, 0);
                    scene.add(textMesh);

                    planes.push({ 
                        mesh: plane, 
                        text: textMesh, 
                        fullText: data.desc, 
                        angle: angle, 
                        isSelected: false 
                    });

                    // Animation fade-in pour l'image
                    let opacity = 0;
                    const fadeIn = () => {
                        opacity += 0.02;
                        material.opacity = opacity;
                        if (opacity < 0.8) {
                            requestAnimationFrame(fadeIn);
                        }
                    };
                    fadeIn();
                }, undefined, (error) => {
                    console.error('Erreur de chargement de l\'image :', data.url, error);
                });
            });
        });

        // Animation de rotation des plans
        function animatePlanes() {
            planes.forEach(plane => {
                if (!plane.isSelected) {
                    plane.angle += 0.01;
                    const radius = 8;
                    plane.mesh.position.x = Math.cos(plane.angle) * radius;
                    plane.mesh.position.z = Math.sin(plane.angle) * radius;
                    plane.text.position.x = plane.mesh.position.x - 2;
                    plane.text.position.z = plane.mesh.position.z;
                    // Assurer que l'opacité revient à 0.8 si non sélectionné
                    if (plane.mesh.material.opacity > 0.8) {
                        let opacity = plane.mesh.material.opacity;
                        const fadeOut = () => {
                            opacity -= 0.02;
                            plane.mesh.material.opacity = opacity;
                            if (opacity > 0.8) {
                                requestAnimationFrame(fadeOut);
                            }
                        };
                        fadeOut();
                    }
                }
            });
        }

        // Fonction pour animer l'écriture progressive du texte
        function animateTextWrite(plane) {
            if (!loadedFont) return; // Attendre que la police soit chargée
            let currentText = '';
            let charIndex = 0;
            plane.text.material.opacity = 1; // Texte visible dès le début
            const write = () => {
                if (charIndex < plane.fullText.length) {
                    currentText += plane.fullText[charIndex];
                    const newGeometry = new THREE.TextGeometry(currentText, {
                        font: loadedFont,
                        size: 0.2, // Police réduite
                        height: 0.01
                    });
                    plane.text.geometry.dispose();
                    plane.text.geometry = newGeometry;
                    charIndex++;
                    setTimeout(write, 25); // Vitesse doublée (50ms -> 25ms)
                }
            };
            write();
        }

        // Gestion des clics pour agrandir les images et afficher le texte
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition = null;
        let targetLookAt = null;

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planes.map(p => p.mesh));
            if (intersects.length > 0) {
                const plane = intersects[0].object;
                if (selectedPlane) {
                    selectedPlane.isSelected = false;
                    // Effacer et cacher le texte précédent
                    selectedPlane.text.geometry.dispose();
                    selectedPlane.text.geometry = new THREE.TextGeometry('', {
                        font: loadedFont,
                        size: 0.2, // Police réduite
                        height: 0.01
                    });
                    selectedPlane.text.material.opacity = 0;
                    // Réduire l'opacité de l'image précédente à 0.8
                    let opacity = selectedPlane.mesh.material.opacity;
                    const fadeOut = () => {
                        opacity -= 0.02;
                        selectedPlane.mesh.material.opacity = opacity;
                        if (opacity > 0.8) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                }
                const clickedPlane = planes.find(p => p.mesh === plane);
                clickedPlane.isSelected = true;
                selectedPlane = clickedPlane;
                targetPosition = plane.position.clone().add(new THREE.Vector3(0, 0, 5));
                targetLookAt = plane.position.clone();

                // Rendre l'image complètement opaque (100%)
                let opacity = clickedPlane.mesh.material.opacity;
                const fadeIn = () => {
                    opacity += 0.02;
                    clickedPlane.mesh.material.opacity = opacity;
                    if (opacity < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                fadeIn();

                // Lancer l'animation d'écriture
                animateTextWrite(clickedPlane);
            }
        }

        // Animation fluide de la caméra
        function animateCamera() {
            if (targetPosition && targetLookAt) {
                camera.position.lerp(targetPosition, 0.1);
                controls.target.lerp(targetLookAt, 0.1);
                controls.update();
                if (camera.position.distanceTo(targetPosition) < 0.1) {
                    targetPosition = null;
                    targetLookAt = null;
                }
            }
        }

        window.addEventListener('click', onClick);

        // Boutons de contrôle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                renderer.domElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
            camera.position.set(0, 5, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            targetPosition = null;
            targetLookAt = null;
            if (selectedPlane) {
                selectedPlane.isSelected = false;
                // Effacer et cacher le texte
                selectedPlane.text.geometry.dispose();
                selectedPlane.text.geometry = new THREE.TextGeometry('', {
                    font: loadedFont,
                    size: 0.2, // Police réduite
                    height: 0.01
                });
                selectedPlane.text.material.opacity = 0;
                // Réduire l'opacité de l'image à 0.8
                let opacity = selectedPlane.mesh.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.02;
                    plane.mesh.material.opacity = opacity;
                    if (opacity > 0.8) {
                        requestAnimationFrame(fadeOut);
                    }
                };
                fadeOut();
                selectedPlane = null;
            }
        });

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Mettre à jour la résolution
        });

        // Boucle d'animation
        function animate() {
            requestAnimationFrame(animate);
            animatePlanes();
            animateCamera();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
