<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expérience 3D Interactive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f5f5e6; /* Fond beige clair */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #333;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background: #555;
        }
        @media (max-width: 768px) {
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="fullscreenBtn">Plein écran</button>
        <button id="resetBtn">Réinitialiser la vue</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialisation de la scène
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5e6); // Fond beige clair

        // Caméra
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        // Rendu
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Améliore la netteté
        document.body.appendChild(renderer.domElement);

        // Contrôles OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Éclairage
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Images et descriptions
        const imageData = [
            { url: 'carte_chatellerault.webp', desc: 'Cette carte propose une représentation minimaliste de Châtellerault, avec ses bâtiments en bleu foncé sur fond blanc. Ce contraste met en valeur la densité bâtie et la structure urbaine de la ville, tout en offrant une lecture épurée et graphique du territoire.' },
            { url: 'carte_châtellerault.webp', desc: 'Carte historique de la région' },
            { url: 'tenerife.jpg', desc: 'Cette photo a été prise à San Cristóbal de La Laguna, une ville peu touristique du nord de Tenerife, contrastant avec le sud de l’île largement dédié à un tourisme de masse. Tandis que les habitants du nord font face à des problèmes de sécheresse, le sud accueille d’immenses complexes touristiques, comme des parcs aquatiques gourmands en eau.' },
            { url: 'amenagement.JPG', desc: 'Les quais de la Vienne illustrent les efforts de redynamisation d’une ville moyenne : réaménagement des berges, valorisation du cadre naturel et mobilités douces cherchent à renforcer l’attractivité du centre face au déclin démographique.' },
            { url: 'meriadek.jpg', desc: 'Quartier des années 60–70, Mériadeck rompt avec l’esthétique bordelaise par son architecture brutaliste et son urbanisme sur dalle. Malgré son apparence minérale, il intègre des espaces végétalisés en hauteur, illustrant une tentative précoce d’urbain-nature.' },
            { url: 'Lyon(1).jpg', desc: 'Cette carte inverse les codes traditionnels : le réseau routier y apparaît en blanc sur un fond bleu profond. Ce contraste met en valeur la complexité et la finesse du maillage urbain lyonnais, offrant une lecture graphique et abstraite de la ville à travers ses voies de circulation.' },
            { url: 'chaban.webp', desc: 'Cette photo montre le pont Chaban-Delmas, ouvrage emblématique de Bordeaux franchissant la Garonne. Sa particularité réside dans son tablier central mobile : au lieu de s’ouvrir latéralement comme un pont-levis classique, un segment du pont s’élève verticalement grâce à un système de pylônes et de câbles, permettant le passage des navires de grand gabarit.' },
            { url: 'shangai.jpg', desc: 'Cette modélisation 3D illustre le quartier de Lujiazui et ses abords, où se côtoient gratte-ciels emblématiques (Shanghai Tower, World Financial Center...) et quartiers résidentiels plus modestes. Le contraste est frappant : verticalité extrême d’un côté, maisons basses et HLM de l’autre. Ce mélange d’échelles et de tissus urbains reflète la complexité et la densité unique de Shanghai.' },
            { url: 'guggenheim.jpg', desc: 'Icône d’architecture contemporaine en titane, le Guggenheim a transformé Bilbao : au-delà de sa forme spectaculaire, il a relancé l’économie locale et amorcé la reconversion urbaine de la ville post-industrielle. Un modèle de régénération par la culture.' }
        ];

        // Création des plans pour les images
        const planes = [];
        const loader = new THREE.TextureLoader();
        let selectedPlane = null;
        let loadedFont = null;

        // Font loader pour le texte
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/gentilis_regular.typeface.json', (font) => {
            loadedFont = font; // Stocker la police chargée
            imageData.forEach((data, index) => {
                loader.load(data.url, (texture) => {
                    // Optimisation des textures pour la qualité
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    const geometry = new THREE.PlaneGeometry(4, 3);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    
                    // Position en spirale
                    const angle = (index / imageData.length) * Math.PI * 2;
                    const radius = 8;
                    plane.position.set(
                        Math.cos(angle) * radius,
                        index * 2 - (imageData.length - 1),
                        Math.sin(angle) * radius
                    );
                    
                    // Inclinaison aléatoire
                    plane.rotation.x = (Math.random() - 0.5) * 0.3;
                    plane.rotation.y = (Math.random() - 0.5) * 0.3;
                    
                    scene.add(plane);

                    // Création du texte (initialement vide)
                    const textGeometry = new THREE.TextGeometry('', {
                        font: loadedFont,
                        size: 0.2, // Police réduite
                        height: 0.01
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: 0x333333,
                        transparent: true,
                        opacity: 0
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(
                        plane.position.x - 2,
                        plane.position.y - 2,
                        plane.position.z
                    );
                    textMesh.rotation.set(plane.rotation.x, plane.rotation.y, 0);
                    scene.add(textMesh);

                    planes.push({ 
                        mesh: plane, 
                        text: textMesh, 
                        fullText: data.desc, 
                        angle: angle, 
                        isSelected: false 
                    });

                    // Animation fade-in pour l'image
                    let opacity = 0;
                    const fadeIn = () => {
                        opacity += 0.02;
                        material.opacity = opacity;
                        if (opacity < 0.8) {
                            requestAnimationFrame(fadeIn);
                        }
                    };
                    fadeIn();
                }, undefined, (error) => {
                    console.error('Erreur de chargement de l\'image :', data.url, error);
                });
            });
        });

        // Animation de rotation des plans
        function animatePlanes() {
            planes.forEach(plane => {
                if (!plane.isSelected) {
                    plane.angle += 0.01;
                    const radius = 8;
                    plane.mesh.position.x = Math.cos(plane.angle) * radius;
                    plane.mesh.position.z = Math.sin(plane.angle) * radius;
                    plane.text.position.x = plane.mesh.position.x - 2;
                    plane.text.position.z = plane.mesh.position.z;
                    // Assurer que l'opacité revient à 0.8 si non sélectionné
                    if (plane.mesh.material.opacity > 0.8) {
                        let opacity = plane.mesh.material.opacity;
                        const fadeOut = () => {
                            opacity -= 0.02;
                            plane.mesh.material.opacity = opacity;
                            if (opacity > 0.8) {
                                requestAnimationFrame(fadeOut);
                            }
                        };
                        fadeOut();
                    }
                }
            });
        }

        // Fonction pour animer l'écriture progressive du texte avec retours à la ligne
        function animateTextWrite(plane) {
            if (!loadedFont) return; // Attendre que la police soit chargée
            
            // Préparer le texte avec des retours à la ligne tous les 60-70 caractères
            function addLineBreaks(text) {
                const maxLineLength = 70;
                let result = '';
                let currentLineLength = 0;
                let words = text.split(' ');
                
                for (let i = 0; i < words.length; i++) {
                    let word = words[i];
                    let wordLength = word.length + (currentLineLength > 0 ? 1 : 0); // +1 pour l'espace
                    
                    if (currentLineLength + wordLength > maxLineLength) {
                        result += '\n';
                        currentLineLength = 0;
                    }
                    
                    result += (currentLineLength > 0 ? ' ' : '') + word;
                    currentLineLength += wordLength;
                }
                
                return result;
            }
            
            const formattedText = addLineBreaks(plane.fullText);
            const lines = formattedText.split('\n');
            let currentText = '';
            let lineIndex = 0;
            plane.text.material.opacity = 1; // Texte visible dès le début
            
            // Paramètres pour l'animation
            const delayPerLine = 50; // 50ms entre chaque ligne, fixe pour toutes les images
            
            let lastUpdateTime = performance.now();
            
            const write = (currentTime) => {
                if (lineIndex < lines.length) {
                    // Vérifier si assez de temps s'est écoulé pour la mise à jour
                    if (currentTime - lastUpdateTime >= delayPerLine) {
                        // Ajouter la ligne complète
                        currentText += (lineIndex > 0 ? '\n' : '') + lines[lineIndex];
                        const newGeometry = new THREE.TextGeometry(currentText, {
                            font: loadedFont,
                            size: 0.2, // Police réduite
                            height: 0.01
                        });
                        plane.text.geometry.dispose();
                        plane.text.geometry = newGeometry;
                        lineIndex++;
                        lastUpdateTime = currentTime;
                    }
                    requestAnimationFrame(write);
                }
            };
            requestAnimationFrame(write);
        }

        // Gestion des clics pour agrandir les images et afficher le texte
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition = null;
        let targetLookAt = null;
        let pendingTextAnimation = null;

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planes.map(p => p.mesh));
            if (intersects.length > 0) {
                const plane = intersects[0].object;
                if (selectedPlane) {
                    selectedPlane.isSelected = false;
                    // Effacer et cacher le texte précédent
                    selectedPlane.text.geometry.dispose();
                    selectedPlane.text.geometry = new THREE.TextGeometry('', {
                        font: loadedFont,
                        size: 0.2, // Police réduite
                        height: 0.01
                    });
                    selectedPlane.text.material.opacity = 0;
                    // Réduire l'opacité de l'image précédente à 0.8
                    let opacity = selectedPlane.mesh.material.opacity;
                    const fadeOut = () => {
                        opacity -= 0.02;
                        selectedPlane.mesh.material.opacity = opacity;
                        if (opacity > 0.8) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                }
                const clickedPlane = planes.find(p => p.mesh === plane);
                clickedPlane.isSelected = true;
                selectedPlane = clickedPlane;
                targetPosition = plane.position.clone().add(new THREE.Vector3(0, 0, 5));
                targetLookAt = plane.position.clone();

                // Rendre l'image complètement opaque (100%)
                let opacity = clickedPlane.mesh.material.opacity;
                const fadeIn = () => {
                    opacity += 0.02;
                    clickedPlane.mesh.material.opacity = opacity;
                    if (opacity < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                fadeIn();

                // Stocker la plane pour l'animation du texte après le zoom
                pendingTextAnimation = clickedPlane;
            }
        }

        // Animation fluide de la caméra
        function animateCamera() {
            if (targetPosition && targetLookAt) {
                camera.position.lerp(targetPosition, 0.1);
                controls.target.lerp(targetLookAt, 0.1);
                controls.update();
                if (camera.position.distanceTo(targetPosition) < 0.1) {
                    // Zoom terminé, lancer l'animation du texte si en attente
                    if (pendingTextAnimation) {
                        animateTextWrite(pendingTextAnimation);
                        pendingTextAnimation = null;
                    }
                    targetPosition = null;
                    targetLookAt = null;
                }
            }
        }

        window.addEventListener('click', onClick);

        // Boutons de contrôle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                renderer.domElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
            camera.position.set(0, 5, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            targetPosition = null;
            targetLookAt = null;
            pendingTextAnimation = null; // Annuler toute animation de texte en attente
            if (selectedPlane) {
                selectedPlane.isSelected = false;
                // Effacer et cacher le texte
                selectedPlane.text.geometry.dispose();
                selectedPlane.text.geometry = new THREE.TextGeometry('', {
                    font: loadedFont,
                    size: 0.2, // Police réduite
                    height: 0.01
                });
                selectedPlane.text.material.opacity = 0;
                // Réduire l'opacité de l'image à 0.8
                let opacity = selectedPlane.mesh.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.02;
                    selectedPlane.mesh.material.opacity = opacity;
                    if (opacity > 0.8) {
                        requestAnimationFrame(fadeOut);
                    }
                };
                fadeOut();
                selectedPlane = null;
            }
        });

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Mettre à jour la résolution
        });

        // Boucle d'animation
        function animate() {
            requestAnimationFrame(animate);
            animatePlanes();
            animateCamera();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
