<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expérience 3D Interactive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f5f5e6; /* Fond beige clair */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #333;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background: #555;
        }
        @media (max-width: 768px) {
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="fullscreenBtn">Plein écran</button>
        <button id="resetBtn">Réinitialiser la vue</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialisation de la scène
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5e6); // Fond beige clair

        // Caméra
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        // Rendu
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Améliore la netteté
        document.body.appendChild(renderer.domElement);

        // Contrôles OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // Éclairage
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Images et descriptions
        const imageData = [
            { url: 'carte_chatellerault.webp', desc: 'A beautiful view of Châtellerault' },
            { url: 'carte_châtellerault.webp', desc: 'Historic map of the region' },
            { url: 'tenerife.jpg', desc: 'Cette photo a été prise à San Cristóbal de La Laguna, une ville peu touristique du nord de Tenerife, contrastant avec le sud de l’île largement dédié à un tourisme de masse. Tandis que les habitants du nord font face à des problèmes de sécheresse, le sud accueille d’immenses complexes touristiques, comme des parcs aquatiques gourmands en eau. Les toits plats et les façades colorées visibles ici sont caractéristiques de l’architecture vernaculaire locale, adaptée au climat sec et doux de l’île. Cette île est un exemple marquant de la tension entre les intérêts touristiques et les besoins fondamentaux de la population locale, notamment en matière de logement, de ressources et d’accès à l’eau.' },
            { url: 'ameagement.JPG', desc: 'Plan d’aménagement urbain détaillé' },
            { url: 'meriadek.jpg', desc: 'Vue du quartier Mériadeck à Bordeaux' },
            { url: 'Marseille.webp', desc: 'Vibrant cityscape of Marseille' },
            { url: 'chaban.webp', desc: 'Cette photo montre le pont Chaban-Delmas, ouvrage emblématique de Bordeaux franchissant la Garonne. Sa particularité réside dans son tablier central mobile : au lieu de s’ouvrir latéralement comme un pont-levis classique, un segment du pont s’élève verticalement grâce à un système de pylônes et de câbles, permettant le passage des navires de grand gabarit. Ce mécanisme d’élévation, à la fois technique et esthétique, reflète une ingénierie contemporaine adaptée aux contraintes fluviales de la ville.' },
            { url: 'carte_chatellerault2.webp', desc: 'Another view of Châtellerault' }
        ];

        // Création des plans pour les images
        const planes = [];
        const loader = new THREE.TextureLoader();
        let selectedPlane = null;
        let loadedFont = null;

        // Font loader pour le texte
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            loadedFont = font; // Stocker la police chargée
            imageData.forEach((data, index) => {
                loader.load(data.url, (texture) => {
                    // Optimisation des textures pour la qualité
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    const geometry = new THREE.PlaneGeometry(4, 3);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    
                    // Position en spirale
                    const angle = (index / imageData.length) * Math.PI * 2;
                    const radius = 8;
                    plane.position.set(
                        Math.cos(angle) * radius,
                        index * 2 - (imageData.length - 1),
                        Math.sin(angle) * radius
                    );
                    
                    // Inclinaison aléatoire
                    plane.rotation.x = (Math.random() - 0.5) * 0.3;
                    plane.rotation.y = (Math.random() - 0.5) * 0.3;
                    
                    scene.add(plane);

                    // Création du texte (initialement vide)
                    const textGroup = new THREE.Group(); // Groupe pour les lignes de texte
                    textGroup.position.set(
                        plane.position.x - 2,
                        plane.position.y - 2,
                        plane.position.z
                    );
                    textGroup.rotation.set(plane.rotation.x, plane.rotation.y, 0);
                    scene.add(textGroup);

                    planes.push({ 
                        mesh: plane, 
                        textGroup: textGroup, 
                        fullText: data.desc, 
                        angle: angle, 
                        isSelected: false 
                    });

                    // Animation fade-in pour l'image
                    let opacity = 0;
                    const fadeIn = () => {
                        opacity += 0.02;
                        material.opacity = opacity;
                        if (opacity < 0.8) {
                            requestAnimationFrame(fadeIn);
                        }
                    };
                    fadeIn();
                }, undefined, (error) => {
                    console.error('Erreur de chargement de l\'image :', data.url, error);
                });
            });
        });

        // Animation de rotation des plans
        function animatePlanes() {
            planes.forEach(plane => {
                if (!plane.isSelected) {
                    plane.angle += 0.01;
                    const radius = 8;
                    plane.mesh.position.x = Math.cos(plane.angle) * radius;
                    plane.mesh.position.z = Math.sin(plane.angle) * radius;
                    plane.textGroup.position.x = plane.mesh.position.x - 2;
                    plane.textGroup.position.z = plane.mesh.position.z;
                    // Assurer que l'opacité revient à 0.8 si non sélectionné
                    if (plane.mesh.material.opacity > 0.8) {
                        let opacity = plane.mesh.material.opacity;
                        const fadeOut = () => {
                            opacity -= 0.02;
                            plane.mesh.material.opacity = opacity;
                            if (opacity > 0.8) {
                                requestAnimationFrame(fadeOut);
                            }
                        };
                        fadeOut();
                    }
                }
            });
        }

        // Fonction pour diviser le texte en lignes
        function splitTextIntoLines(text, isChaban = false) {
            const lines = [];
            let currentLine = '';
            let charCount = 0;
            let wordCount = 0;
            const words = text.split(' ');

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const wordLength = word.length + (currentLine ? 1 : 0); // +1 pour l'espace

                if (isChaban && currentLine === 'Cette photo montre le' && word === 'pont') {
                    // Forcer un saut de ligne après "pont" pour chaban.webp
                    currentLine += ' ' + word;
                    lines.push(currentLine);
                    currentLine = '';
                    charCount = 0;
                    wordCount = 0;
                    continue;
                }

                if (charCount + wordLength > 60 || (charCount > 50 && wordCount >= 5)) {
                    lines.push(currentLine);
                    currentLine = word;
                    charCount = word.length;
                    wordCount = 1;
                } else {
                    currentLine += (currentLine ? ' ' : '') + word;
                    charCount += wordLength;
                    wordCount++;
                }
            }

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines;
        }

        // Fonction pour animer l'écriture progressive du texte avec lignes
        function animateTextWrite(plane) {
            if (!loadedFont) return; // Attendre que la police soit chargée

            // Nettoyer les anciens meshes de texte
            plane.textGroup.children.forEach(child => {
                child.geometry.dispose();
                plane.textGroup.remove(child);
            });

            // Diviser le texte en lignes
            const isChaban = plane.fullText.includes('pont Chaban-Delmas');
            const lines = splitTextIntoLines(plane.fullText, isChaban);

            let currentText = lines.map(() => ''); // Texte actuel pour chaque ligne
            let charIndex = 0; // Index global du caractère
            let lineIndex = 0; // Index de la ligne actuelle
            let totalChars = lines.join('').length; // Total des caractères

            plane.textGroup.children.forEach(child => plane.textGroup.remove(child)); // Nettoyer

            // Créer un mesh pour chaque ligne
            const textMeshes = lines.map((_, i) => {
                const geometry = new THREE.TextGeometry('', {
                    font: loadedFont,
                    size: 0.3,
                    height: 0.01
                });
                const material = new THREE.MeshBasicMaterial({
                    color: 0x333333,
                    transparent: true,
                    opacity: 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = -i * 0.4; // Espacement vertical des lignes
                plane.textGroup.add(mesh);
                return mesh;
            });

            const write = () => {
                if (charIndex < totalChars) {
                    // Trouver la ligne actuelle
                    let currentCharCount = 0;
                    let targetLineIndex = 0;
                    for (let i = 0; i < lines.length; i++) {
                        if (charIndex < currentCharCount + lines[i].length) {
                            targetLineIndex = i;
                            break;
                        }
                        currentCharCount += lines[i].length;
                    }

                    if (targetLineIndex !== lineIndex) {
                        lineIndex = targetLineIndex;
                    }

                    // Ajouter un caractère à la ligne actuelle
                    currentText[lineIndex] = lines[lineIndex].slice(0, charIndex - currentCharCount + 1);
                    const newGeometry = new THREE.TextGeometry(currentText[lineIndex], {
                        font: loadedFont,
                        size: 0.3,
                        height: 0.01
                    });
                    textMeshes[lineIndex].geometry.dispose();
                    textMeshes[lineIndex].geometry = newGeometry;

                    charIndex++;
                    setTimeout(write, 12); // Vitesse d'écriture (12ms par caractère)
                }
            };
            write();
        }

        // Gestion des clics pour agrandir les images et afficher le texte
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition = null;
        let targetLookAt = null;

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planes.map(p => p.mesh));
            if (intersects.length > 0) {
                const plane = intersects[0].object;
                if (selectedPlane) {
                    selectedPlane.isSelected = false;
                    // Effacer et cacher le texte précédent
                    selectedPlane.textGroup.children.forEach(child => {
                        child.geometry.dispose();
                        selectedPlane.textGroup.remove(child);
                    });
                    // Réduire l'opacité de l'image précédente à 0.8
                    let opacity = selectedPlane.mesh.material.opacity;
                    const fadeOut = () => {
                        opacity -= 0.02;
                        selectedPlane.mesh.material.opacity = opacity;
                        if (opacity > 0.8) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                }
                const clickedPlane = planes.find(p => p.mesh === plane);
                clickedPlane.isSelected = true;
                selectedPlane = clickedPlane;
                targetPosition = plane.position.clone().add(new THREE.Vector3(0, 0, 5));
                targetLookAt = plane.position.clone();

                // Rendre l'image complètement opaque (100%)
                let opacity = clickedPlane.mesh.material.opacity;
                const fadeIn = () => {
                    opacity += 0.02;
                    clickedPlane.mesh.material.opacity = opacity;
                    if (opacity < 1.0) {
                        requestAnimationFrame(fadeIn);
                    }
                };
                fadeIn();

                // Lancer l'animation d'écriture
                animateTextWrite(clickedPlane);
            }
        }

        // Animation fluide de la caméra
        function animateCamera() {
            if (targetPosition && targetLookAt) {
                camera.position.lerp(targetPosition, 0.1);
                controls.target.lerp(targetLookAt, 0.1);
                controls.update();
                if (camera.position.distanceTo(targetPosition) < 0.1) {
                    targetPosition = null;
                    targetLookAt = null;
                }
            }
        }

        window.addEventListener('click', onClick);

        // Boutons de contrôle
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                renderer.domElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
            camera.position.set(0, 5, 15);
            controls.target.set(0, 0, 0);
            controls.update();
            targetPosition = null;
            targetLookAt = null;
            if (selectedPlane) {
                selectedPlane.isSelected = false;
                // Effacer et cacher le texte
                selectedPlane.textGroup.children.forEach(child => {
                    child.geometry.dispose();
                    selectedPlane.textGroup.remove(child);
                });
                // Réduire l'opacité de l'image à 0.8
                let opacity = selectedPlane.mesh.material.opacity;
                const fadeOut = () => {
                    opacity -= 0.02;
                    selectedPlane.mesh.material.opacity = opacity;
                    if (opacity > 0.8) {
                        requestAnimationFrame(fadeOut);
                    }
                };
                fadeOut();
                selectedPlane = null;
            }
        });

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Mettre à jour la résolution
        });

        // Boucle d'animation
        function animate() {
            requestAnimationFrame(animate);
            animatePlanes();
            animateCamera();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
